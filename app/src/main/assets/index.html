<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SNES Pro Fixed</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body, html { width: 100%; height: 100%; background-color: #000; overflow: hidden; position: fixed; }
        
        canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
            object-fit: fill; 
            image-rendering: pixelated;
        }

        #game-toast {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(30, 30, 30, 0.95);
            color: #fff;
            padding: 12px 24px;
            border-radius: 25px;
            font-family: sans-serif;
            font-weight: bold;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 9999;
            border: 1px solid #777;
            text-align: center;
        }

        #fps-overlay {
            position: absolute;
            top: 5px; left: 5px; color: #00FF00;
            font-family: monospace; font-size: 12px;
            pointer-events: none;
        }
    </style>
    <script src="/assets/nostalgist.umd.js"></script>
</head>
<body>

<div id="fps-overlay">FPS: 0</div>
<div id="game-toast">Info</div>
<canvas id="game-canvas" tabindex="1"></canvas>

<script>
    let nostalgistInstance = null;
    let currentRomName = "game"; 

    const canvas = document.getElementById('game-canvas');
    const toastElement = document.getElementById('game-toast');
    const fpsElement = document.getElementById('fps-overlay');

    // --- Toast UI ---
    let toastTimeout;
    function showToast(msg, isError = false) {
        toastElement.innerText = msg;
        toastElement.style.color = isError ? "#FF5555" : "#FFFFFF";
        toastElement.style.borderColor = isError ? "#FF5555" : "#777";
        toastElement.style.opacity = "1";
        clearTimeout(toastTimeout);
        toastTimeout = setTimeout(() => { toastElement.style.opacity = "0"; }, 2500);
    }

    // --- FPS ---
    let frameCount = 0; let lastTime = performance.now();
    function loopFPS() {
        const now = performance.now(); frameCount++;
        if (now - lastTime >= 1000) { fpsElement.innerText = "FPS: " + frameCount; frameCount = 0; lastTime = now; }
        requestAnimationFrame(loopFPS);
    }
    requestAnimationFrame(loopFPS);

    // --- Controls ---
    const keyMap = {
        'UP': {code:'ArrowUp', key:'ArrowUp', keyCode:38},
        'DOWN': {code:'ArrowDown', key:'ArrowDown', keyCode:40},
        'LEFT': {code:'ArrowLeft', key:'ArrowLeft', keyCode:37},
        'RIGHT': {code:'ArrowRight', key:'ArrowRight', keyCode:39},
        'A': {code:'KeyX', key:'x', keyCode:88},
        'B': {code:'KeyZ', key:'z', keyCode:90},
        'X': {code:'KeyS', key:'s', keyCode:83},
        'Y': {code:'KeyA', key:'a', keyCode:65},
        'L': {code:'KeyQ', key:'q', keyCode:81},
        'R': {code:'KeyW', key:'w', keyCode:87},
        'START': {code:'Enter', key:'Enter', keyCode:13},
        'SELECT': {code:'ShiftRight', key:'Shift', keyCode:16}
    };
    function androidButtonEvent(btn, isDown) {
        const m = keyMap[btn]; if(!m) return;
        if(document.activeElement !== canvas) canvas.focus();
        const evt = new KeyboardEvent(isDown?'keydown':'keyup', {
            bubbles:true, cancelable:true, view:window,
            key:m.key, code:m.code, keyCode:m.keyCode, which:m.keyCode
        });
        canvas.dispatchEvent(evt); window.dispatchEvent(evt);
    }

    // --- SAVE STATE (CORREÇÃO AQUI) ---
    async function triggerSaveState() {
        if (!nostalgistInstance) return showToast("Sem jogo!", true);
        try {
            showToast("Gerando Save...");
            
            // 1. Obtém o resultado do save
            let result = await nostalgistInstance.saveState();
            
            // 2. CORREÇÃO: Verifica o tipo de dado recebido
            let finalBlob = null;

            if (result instanceof Blob) {
                // Se já for Blob, usa direto
                finalBlob = result;
            } else if (result.state) {
                // Se for um objeto { state: Blob, thumbnail: ... }
                // Alguns cores retornam um objeto complexo
                if (result.state instanceof Blob) {
                    finalBlob = result.state;
                } else {
                    // Se o .state for Uint8Array
                    finalBlob = new Blob([result.state]);
                }
            } else {
                // Se for apenas Uint8Array (Buffer bruto)
                finalBlob = new Blob([result]);
            }

            // 3. Converte Blob para Base64
            const reader = new FileReader();
            reader.readAsDataURL(finalBlob); 
            
            reader.onloadend = function() {
                const base64data = reader.result;
                // Envia para o Kotlin salvar no arquivo
                if (window.AndroidInterface) {
                    window.AndroidInterface.saveStateToDisk(base64data, currentRomName);
                } else {
                    showToast("Interface Android desconectada", true);
                }
            };
            
            reader.onerror = function() {
                showToast("Erro ao ler Blob", true);
            };

        } catch (e) {
            console.error(e);
            showToast("Erro JS: " + e.message, true);
        }
    }

    // --- LOAD STATE ---
    function triggerLoadState() {
        if (!nostalgistInstance) return showToast("Sem jogo!", true);
        showToast("Buscando Save...");
        if (window.AndroidInterface) {
            window.AndroidInterface.loadStateFromDisk(currentRomName);
        } else {
             showToast("Interface Android desconectada", true);
        }
    }

    // Chamado pelo Kotlin quando o arquivo é lido
    async function receiveStateFromAndroid(base64Data) {
        try {
            showToast("Aplicando Save...");
            const res = await fetch("data:application/octet-stream;base64," + base64Data);
            const blob = await res.blob();
            
            await nostalgistInstance.loadState(blob);
            showToast("Carregado com Sucesso!");
        } catch (e) {
            showToast("Save inválido ou corrompido", true);
            console.error(e);
        }
    }

    // --- Launch ---
    async function launchGame(romBase64, fileName) {
        try {
            if (nostalgistInstance) { await nostalgistInstance.exit(); nostalgistInstance = null; }
            
            // Limpa extensão do nome para usar no save
            currentRomName = fileName.replace(/\.[^/.]+$/, "");
            
            const bin = atob(romBase64);
            const bytes = new Uint8Array(bin.length);
            for (let i=0; i<bin.length; i++) bytes[i] = bin.charCodeAt(i);
            const file = new File([bytes], fileName);

            nostalgistInstance = await Nostalgist.launch({
                element: canvas,
                core: 'snes9x2005',
                rom: file,
                resolveCoreJs: (c) => `/assets/cores/${c}_libretro.js`,
                resolveCoreWasm: (c) => `/assets/cores/${c}_libretro.wasm`,
                retroarchConfig: {
                    video_scale_integer: "false",
                    video_aspect_ratio_auto: "true",
                    video_smooth: "false",
                    audio_latency: "96",
                    video_threaded: "true"
                }
            });
            setTimeout(() => canvas.focus(), 500);
            showToast("Jogo Iniciado!");
        } catch (e) {
            showToast("Erro: " + e.message, true);
        }
    }
</script>
</body>
    </html>
