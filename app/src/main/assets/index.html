<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SNES 2005 Complete</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }
        body, html { width: 100%; height: 100%; background-color: #000; overflow: hidden; position: fixed; }
        
        canvas {
            display: block;
            width: 100vw !important;
            height: 100vh !important;
            object-fit: fill;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #fps-overlay {
            position: absolute;
            top: 5px;
            left: 5px;
            color: #00FF00;
            font-family: monospace;
            font-size: 16px;
            font-weight: bold;
            background: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 9999;
        }
    </style>
    <script src="/assets/nostalgist.umd.js"></script>
</head>
<body>

<div id="fps-overlay">FPS: 0</div>
<canvas id="game-canvas" tabindex="1"></canvas>

<script>
    let nostalgistInstance = null;
    let savedStateBlob = null; // Variável para guardar o save na memória RAM
    const canvas = document.getElementById('game-canvas');
    const fpsElement = document.getElementById('fps-overlay');

    // --- FPS COUNTER ---
    let frameCount = 0;
    let lastTime = performance.now();
    function loopFPS() {
        const now = performance.now();
        frameCount++;
        if (now - lastTime >= 1000) {
            fpsElement.innerText = "FPS: " + frameCount;
            frameCount = 0;
            lastTime = now;
        }
        requestAnimationFrame(loopFPS);
    }
    requestAnimationFrame(loopFPS);

    // --- KEY MAPPING (Incluindo L e R) ---
    // q = L, w = R (Padrão RetroArch Web)
    const keyMap = {
        'UP':    { code: 'ArrowUp',    key: 'ArrowUp',    keyCode: 38 },
        'DOWN':  { code: 'ArrowDown',  key: 'ArrowDown',  keyCode: 40 },
        'LEFT':  { code: 'ArrowLeft',  key: 'ArrowLeft',  keyCode: 37 },
        'RIGHT': { code: 'ArrowRight', key: 'ArrowRight', keyCode: 39 },
        'A':     { code: 'KeyX',       key: 'x',          keyCode: 88 },
        'B':     { code: 'KeyZ',       key: 'z',          keyCode: 90 },
        'X':     { code: 'KeyS',       key: 's',          keyCode: 83 },
        'Y':     { code: 'KeyA',       key: 'a',          keyCode: 65 },
        'L':     { code: 'KeyQ',       key: 'q',          keyCode: 81 }, // NOVO
        'R':     { code: 'KeyW',       key: 'w',          keyCode: 87 }, // NOVO
        'START': { code: 'Enter',      key: 'Enter',      keyCode: 13 },
        'SELECT':{ code: 'ShiftRight', key: 'Shift',      keyCode: 16 }
    };

    // --- INPUT HANDLER ---
    function androidButtonEvent(btnName, isDown) {
        const mapping = keyMap[btnName];
        if (!mapping) return;
        
        if (document.activeElement !== canvas) canvas.focus();

        const eventName = isDown ? 'keydown' : 'keyup';
        const event = new KeyboardEvent(eventName, {
            bubbles: true, cancelable: true, view: window,
            key: mapping.key, code: mapping.code, keyCode: mapping.keyCode, which: mapping.keyCode,
        });
        canvas.dispatchEvent(event);
        window.dispatchEvent(event);
    }

    // --- SAVE / LOAD STATE FUNCTIONS ---
    async function triggerSaveState() {
        if (!nostalgistInstance) return;
        try {
            console.log("Saving state...");
            // Salva o estado em um Blob na memória RAM
            const state = await nostalgistInstance.saveState();
            savedStateBlob = state;
            alert("Estado Salvo na Memória!");
        } catch (e) {
            console.error(e);
            alert("Erro ao salvar: " + e.message);
        }
    }

    async function triggerLoadState() {
        if (!nostalgistInstance) return;
        if (!savedStateBlob) {
            alert("Nenhum estado salvo encontrado!");
            return;
        }
        try {
            console.log("Loading state...");
            await nostalgistInstance.loadState(savedStateBlob);
            console.log("State loaded.");
        } catch (e) {
            console.error(e);
            alert("Erro ao carregar: " + e.message);
        }
    }

    // --- LAUNCH GAME ---
    async function launchGame(base64Rom, fileName) {
        try {
            if (nostalgistInstance) {
                await nostalgistInstance.exit();
                nostalgistInstance = null;
                savedStateBlob = null; // Reseta save ao mudar de jogo
            }

            const binaryString = atob(base64Rom);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const romFile = new File([bytes], fileName);

            // INICIANDO COM CORE 2005 (Como solicitado)
            nostalgistInstance = await Nostalgist.launch({
                element: canvas,
                
                // Certifique-se de ter 'snes9x2005_libretro.js' e '.wasm'
                core: 'snes9x2005', 
                
                rom: romFile,
                resolveCoreJs: (core) => `/assets/cores/${core}_libretro.js`,
                resolveCoreWasm: (core) => `/assets/cores/${core}_libretro.wasm`,

                retroarchConfig: {
                    video_scale_integer: "false",
                    video_aspect_ratio_auto: "true",
                    video_smooth: "false", // Pixels nítidos
                    
                    // Configurações de latência moderada para 2005
                    audio_latency: "128", 
                    video_vsync: "true",
                    video_threaded: "true"
                }
            });

            setTimeout(() => {
                canvas.focus();
            }, 1000);

        } catch (e) {
            alert("Erro Fatal: " + e.message);
        }
    }
</script>
</body>
</html>
