<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SNES TAS Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body, html { width: 100%; height: 100%; background-color: #000; overflow: hidden; position: fixed; }
        
        canvas {
            display: block; width: 100vw !important; height: 100vh !important; object-fit: fill; image-rendering: pixelated;
        }

        .scanlines {
            position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.4) 50%, rgba(0,0,0,0.4));
            background-size: 100% 4px; pointer-events: none; z-index: 10; display: none;
        }

        #game-toast {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            background-color: rgba(30,30,30,0.9); color: #fff; border: 1px solid #555;
            padding: 10px 20px; border-radius: 20px; font-family: monospace; font-weight: bold;
            opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 9999;
        }

        #fps-overlay {
            position: absolute; top: 5px; left: 5px; color: #00FF00; font-family: monospace; font-size: 12px; pointer-events: none;
        }
        
        #tas-status {
            position: absolute; top: 5px; right: 5px; color: #FF0000; font-family: monospace; font-size: 12px; pointer-events: none; display: none;
        }

        #input-display {
            position: absolute; bottom: 5px; left: 5px; color: #FFFFFF; font-family: monospace; font-size: 10px; pointer-events: none; background: rgba(0,0,0,0.5); padding: 2px;
        }
    </style>
    <script src="/assets/nostalgist.umd.js"></script>
</head>
<body>

<div id="fps-overlay">FPS: 0</div>
<div id="tas-status">‚óè REC</div>
<div id="input-display">Inputs: </div>
<div id="game-toast">Info</div>
<div id="scanline-layer" class="scanlines"></div>
<canvas id="game-canvas" tabindex="1"></canvas>

<script>
    let nostalgistInstance = null;
    let currentRomName = "game"; 
    
    // --- VARI√ÅVEIS TAS ---
    let tasInputs = [];    // Hist√≥rico: {f: 120, k: 'A', d: true}
    let currentFrame = 0;  // Frame atual do jogo
    let isRecording = false;
    let isPlaying = false;
    let isPaused = false;
    let pressedKeys = new Set(); // Para display de inputs atuais

    // --- FPS CALCULATION ---
    let fps = 0;
    let frameCount = 0;
    let lastFpsUpdate = performance.now();

    const canvas = document.getElementById('game-canvas');
    const toastElement = document.getElementById('game-toast');
    const tasStatus = document.getElementById('tas-status');

    function showToast(msg, isError = false) {
        toastElement.innerText = msg;
        toastElement.style.color = isError ? "#FF5555" : "#FFFFFF";
        toastElement.style.opacity = "1";
        setTimeout(() => { toastElement.style.opacity = "0"; }, 2500);
    }

    // --- GAME LOOP & FRAME COUNTER ---
    function gameLoop() {
        frameCount++;
        let now = performance.now();
        if (now - lastFpsUpdate >= 1000) {
            fps = frameCount;
            frameCount = 0;
            lastFpsUpdate = now;
            document.getElementById('fps-overlay').innerText = `FPS: ${fps}`;
        }

        // Update input display
        document.getElementById('input-display').innerText = `Inputs: ${Array.from(pressedKeys).join(' ')}`;

        if (nostalgistInstance && !isPaused) {
            currentFrame++;

            // Se estiver em Playback, injeta os inputs deste frame
            if (isPlaying) {
                // Filtra inputs que acontecem neste frame exato
                const inputsNow = tasInputs.filter(i => i.f === currentFrame);
                inputsNow.forEach(i => {
                    simulateKey(i.k, i.d);
                    // Update pressedKeys for playback too
                    if (i.d) pressedKeys.add(i.k); else pressedKeys.delete(i.k);
                });

                // Se acabou os inputs gravados, para o playback
                if (inputsNow.length === 0 && currentFrame > tasInputs[tasInputs.length-1]?.f + 60) {
                     // Espera 1 segundo de sil√™ncio antes de parar
                     // isPlaying = false;
                }
            }
        }
        requestAnimationFrame(gameLoop);
    }
    requestAnimationFrame(gameLoop);

    // --- CONTROLES TAS ---

    function rewind() {
        let targetFrame = Math.max(0, currentFrame - 100);
        tasInputs = tasInputs.filter(i => i.f <= targetFrame);
        currentFrame = targetFrame;
        showToast(`Rewound to frame ${currentFrame} (inputs truncated)`);
    }

    function toggleRecording() {
        if (isPlaying) { isPlaying = false; showToast("Playback Parado"); }
        isRecording = !isRecording;
        tasStatus.style.display = isRecording ? "block" : "none";

        if (isRecording) {
            // Se estamos no frame 0, limpa tudo. Se estamos no meio do jogo, mantemos o passado (Rerecord)
            if (currentFrame < 100) tasInputs = [];
            showToast("üî¥ GRAVANDO TAS...");
        } else {
            showToast("Grava√ß√£o Finalizada.");
            triggerTasSave(); // Save TAS automatically when stopping recording
        }
    }

    async function togglePlayback() {
        if (isRecording) toggleRecording(); // Para grava√ß√£o
        isPlaying = !isPlaying;
        if (isPlaying) {
            // Reset the game to initial state
            if (nostalgistInstance) {
                await nostalgistInstance.reset();
            }
            currentFrame = 0; // Start from frame 0
            if (isPaused) {
                await nostalgistInstance.resume();
                isPaused = false;
            }
            showToast("üü¢ REPRODUZINDO... (Reset game to start if needed)");
        } else {
            showToast("Playback Parado.");
        }
    }

    async function togglePause() {
        if (!nostalgistInstance) return;
        if (isPaused) {
            await nostalgistInstance.resume();
            isPaused = false;
            showToast("Resumido");
        } else {
            await nostalgistInstance.pause();
            isPaused = true;
            showToast("Pausado");
        }
    }
    
    async function frameAdvance() {
        if (!nostalgistInstance) return;
        if (!isPaused) {
            await nostalgistInstance.pause();
            isPaused = true;
            showToast("Pausado (Modo Step)");
        } else {
            // Avan√ßa exatamente 1 frame
            await nostalgistInstance.resume();
            await new Promise(resolve => requestAnimationFrame(resolve));
            await nostalgistInstance.pause();
            currentFrame++;
            showToast(`Frame: ${currentFrame}`);
        }
    }

    // --- INPUT HANDLER COM GRAVA√á√ÉO ---
    const keyMap = {
        'UP': {code:'ArrowUp', key:'ArrowUp', keyCode:38},
        'DOWN': {code:'ArrowDown', key:'ArrowDown', keyCode:40},
        'LEFT': {code:'ArrowLeft', key:'ArrowLeft', keyCode:37},
        'RIGHT': {code:'ArrowRight', key:'ArrowRight', keyCode:39},
        'A': {code:'KeyX', key:'x', keyCode:88},
        'B': {code:'KeyZ', key:'z', keyCode:90},
        'X': {code:'KeyS', key:'s', keyCode:83},
        'Y': {code:'KeyA', key:'a', keyCode:65},
        'L': {code:'KeyQ', key:'q', keyCode:81},
        'R': {code:'KeyW', key:'w', keyCode:87},
        'START': {code:'Enter', key:'Enter', keyCode:13},
        'SELECT': {code:'ShiftRight', key:'Shift', keyCode:16},
        'TURBO': {code:'Space', key:' ', keyCode:32}
    };

    function androidButtonEvent(btn, isDown) {
        // 1. Grava o Input se estiver gravando
        if (isRecording) {
            tasInputs.push({
                f: currentFrame, // Salva o frame atual
                k: btn,
                d: isDown
            });
        }

        // 2. Atualiza estado dos bot√µes pressionados
        if (isDown) {
            pressedKeys.add(btn);
        } else {
            pressedKeys.delete(btn);
        }

        // 3. Executa o Input (mesmo em playback, para permitir interven√ß√£o)
        simulateKey(btn, isDown);
    }

    function simulateKey(btnName, isDown) {
        const m = keyMap[btnName]; if(!m) return;
        if(document.activeElement !== canvas) canvas.focus();
        const evt = new KeyboardEvent(isDown?'keydown':'keyup', {
            bubbles:true, cancelable:true, view:window,
            key:m.key, code:m.code, keyCode:m.keyCode, which:m.keyCode
        });
        canvas.dispatchEvent(evt); window.dispatchEvent(evt);
    }

    // --- SAVE / LOAD BUNDLE (Estado + TAS) ---

    async function triggerTasSave() {
        try {
            showToast("Salvando TAS...");
            const bundle = {
                inputs: tasInputs,
                frame: currentFrame
            };
            if (window.AndroidInterface) {
                window.AndroidInterface.saveTasBundleToDisk(JSON.stringify(bundle), currentRomName);
            }
        } catch (e) { showToast("Erro Save TAS: " + e.message, true); }
    }

    // Chamado pelo Android com o JSON lido do disco
    function receiveTasBundle(jsonString) {
        try {
            showToast("Carregando TAS...");
            const bundle = JSON.parse(jsonString);

            // 1. Restaura o TAS
            tasInputs = bundle.inputs;
            currentFrame = bundle.frame;

            // L√ìGICA DE RERECORDING:
            // Se estivermos gravando, cortamos qualquer input que exista AP√ìS este frame
            if (isRecording) {
                tasInputs = tasInputs.filter(i => i.f <= currentFrame);
                showToast("Rerecord: Futuro apagado.");
            }

            showToast("TAS Carregado! Frame: " + currentFrame);

        } catch (e) {
            console.error(e);
            showToast("Erro TAS", true);
        }
    }

    function triggerTasLoad() {
        if (window.AndroidInterface) window.AndroidInterface.loadTasBundleFromDisk(currentRomName);
    }

    function setScanlines(enable) {
        document.getElementById('scanline-layer').style.display = enable ? "block" : "none";
    }

    async function launchGame(romBase64, fileName) {
        try {
            if (nostalgistInstance) { await nostalgistInstance.exit(); nostalgistInstance = null; }
            currentRomName = fileName.replace(/\.[^/.]+$/, "");
            tasInputs = []; currentFrame = 0; isRecording = false; isPlaying = false; isPaused = false;
            
            const bin = atob(romBase64);
            const bytes = new Uint8Array(bin.length);
            for (let i=0; i<bin.length; i++) bytes[i] = bin.charCodeAt(i);
            const file = new File([bytes], fileName);

            nostalgistInstance = await Nostalgist.launch({
                element: canvas,
                core: 'snes9x2005',
                rom: file,
                resolveCoreJs: (c) => `/assets/cores/${c}_libretro.js`,
                resolveCoreWasm: (c) => `/assets/cores/${c}_libretro.wasm`,
                retroarchConfig: {
                    input_hold_fast_forward: "space",
                    video_scale_integer: "false",
                    video_aspect_ratio_auto: "true",
                    video_smooth: "false",
                    audio_latency: "96",
                    video_threaded: "true"
                }
            });
            setTimeout(() => { canvas.focus(); }, 500);
            if(window.AndroidInterface) window.AndroidInterface.onGameLoaded();
            showToast("Jogo Iniciado!");
        } catch (e) { showToast("Erro: " + e.message, true); }
    }
</script>
</body>
</html>
